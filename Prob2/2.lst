   1               		.file	"2.c"
   2               	__SREG__ = 0x3f
   3               	__SP_H__ = 0x3e
   4               	__SP_L__ = 0x3d
   5               	__CCP__  = 0x34
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   8               		.global __do_copy_data
   9               		.global __do_clear_bss
  11               		.text
  12               	.Ltext0:
  70               	.global	keypad
  71               		.data
  74               	keypad:
  75 0000 30        		.byte	48
  76 0001 31        		.byte	49
  77 0002 32        		.byte	50
  78 0003 33        		.byte	51
  79 0004 34        		.byte	52
  80 0005 35        		.byte	53
  81 0006 36        		.byte	54
  82 0007 37        		.byte	55
  83 0008 38        		.byte	56
  84 0009 39        		.byte	57
  85 000a 41        		.byte	65
  86 000b 42        		.byte	66
  87 000c 43        		.byte	67
  88 000d 44        		.byte	68
  89 000e 45        		.byte	69
  90 000f 46        		.byte	70
  91               		.text
  93               	.global	main
  95               	main:
   1:2.c           **** // ***********************************************************
   2:2.c           **** 
   3:2.c           **** 
   4:2.c           **** //Prob 4.2.....Write a code to toggle LED's on PORTB at the rate of 1 sec when 1 is pressed fromthe
   5:2.c           **** 
   6:2.c           **** // ***********************************************************
   7:2.c           **** 
   8:2.c           **** 
   9:2.c           **** 
  10:2.c           **** #include <avr\io.h>              // Most basic include files
  11:2.c           **** #include <avr\interrupt.h>       // Add the necessary ones
  12:2.c           **** #include<util/delay.h>
  13:2.c           **** 
  14:2.c           **** 
  15:2.c           **** #define  key_prt  PORTC
  16:2.c           **** #define  key_ddr DDRC
  17:2.c           **** #define  key_pin PINC
  18:2.c           **** 
  19:2.c           **** void delay_ms(unsigned int );
  20:2.c           **** 
  21:2.c           **** unsigned char keypad[4][4] = { '0','1','2','3',
  22:2.c           **** 										 '4','5','6','7',
  23:2.c           **** 										 '8','9','A','B',
  24:2.c           **** 										 'C','D','E','F'};
  25:2.c           **** // ***********************************************************
  26:2.c           **** 
  27:2.c           **** // Main program
  28:2.c           **** 
  29:2.c           **** 
  30:2.c           **** 
  31:2.c           **** int main(void)
  32:2.c           **** {
  96               	,__SP_H__
  97               	/* prologue: function */
  98               	/* frame size = 2 */
 100 0002 CF93      	.LM1:
 101 0004 00D0      		ldi r30,lo8(49)
 102 0006 CDB7      		ldi r31,hi8(49)
 103 0008 DEB7      		ldi r24,lo8(-1)
 104               		st Z,r24
  33:2.c           ****   	unsigned char colloc, rowloc;
  34:2.c           ****   	
  35:2.c           ****   	DDRD = 0xFF;
 106               	 r30,lo8(53)
 107               		ldi r31,hi8(53)
 108 000a E1E3      		ldi r24,lo8(-1)
 109 000c F0E0      		st Z,r24
 111 0010 8083      	.LM3:
  36:2.c           ****    key_prt = 0xFF;
 112               	30,lo8(52)
 113               		ldi r31,hi8(52)
 114 0012 E5E3      		ldi r24,lo8(-16)
 115 0014 F0E0      		st Z,r24
 116 0016 8FEF      	.L2:
  37:2.c           ****    key_ddr = 0xF0;
 118               		ldi r26,lo8(53)
 119               		ldi r27,hi8(53)
 120 001a E4E3      		ldi r30,lo8(53)
 121 001c F0E0      		ldi r31,hi8(53)
 122 001e 80EF      		ld r24,Z
 123 0020 8083      		andi r24,lo8(15)
 124               		st X,r24
  38:2.c           **** 
  39:2.c           ****    while(1)
  40:2.c           ****     {             // Infinite loop; define here the
  41:2.c           ****          do
  42:2.c           ****          {
  43:2.c           ****  				key_prt &= 0x0f;
 125               		68,0,44,.LM5-.LFBB1
 126               	.LM5:
 127 0022 A5E3      		ldi r30,lo8(51)
 128 0024 B0E0      		ldi r31,hi8(51)
 129 0026 E5E3      		ld r24,Z
 130 0028 F0E0      		andi r24,lo8(15)
 131 002a 8081      		std Y+2,r24
 133 002e 8C93      	.LM6:
  44:2.c           ****  			   colloc = (PINC & 0x0F);
 134               	Y+2
 135               		cpi r24,lo8(15)
 136 0030 E3E3      		brne .L2
 137 0032 F0E0      	.L3:
 139 0036 8F70      	.LM7:
 140 0038 8A83      		ldi r24,lo8(20)
  45:2.c           ****    		}while(colloc != 0x0F);
 141               	5,hi8(20)
 142               		rcall delay_ms
 144 003c 8F30      	.LM8:
 145 003e 01F4      		ldi r30,lo8(51)
 146               		ldi r31,hi8(51)
  46:2.c           ****    		
  47:2.c           ****    		do
  48:2.c           ****          {
  49:2.c           ****  				do
  50:2.c           ****  				{
  51:2.c           ****  				   delay_ms(20);
 147               	4,Z
 148               		andi r24,lo8(15)
 149 0040 84E1      		std Y+2,r24
 151 0044 00D0      	.LM9:
  52:2.c           ****  				   colloc = (PINC & 0x0F);
 152               	r24,Y+2
 153               		cpi r24,lo8(15)
 154 0046 E3E3      		breq .L3
 156 004a 8081      	.LM10:
 157 004c 8F70      		ldi r24,lo8(20)
 158 004e 8A83      		ldi r25,hi8(20)
  53:2.c           ****    	   	}while(colloc == 0x0F);
 159               	delay_ms
 161 0050 8A81      	.LM11:
 162 0052 8F30      		ldi r30,lo8(51)
 163 0054 01F0      		ldi r31,hi8(51)
  54:2.c           ****    	   	
  55:2.c           ****    		   delay_ms(20);
 164               	24,Z
 165               		andi r24,lo8(15)
 166 0056 84E1      		std Y+2,r24
 168 005a 00D0      	.LM12:
  56:2.c           ****    		   colloc = (PINC & 0x0F);
 169               	r24,Y+2
 170               		cpi r24,lo8(15)
 171 005c E3E3      		breq .L3
 173 0060 8081      	.LM13:
 174 0062 8F70      		ldi r30,lo8(53)
 175 0064 8A83      		ldi r31,hi8(53)
  57:2.c           ****    	  	}while(colloc == 0x0F);
 176               	4,lo8(-17)
 177               		st Z,r24
 179 0068 8F30      	.LM14:
 180 006a 01F0      		ldi r30,lo8(51)
  58:2.c           ****    	  	
  59:2.c           ****    	  while(1)
  60:2.c           ****         {
  61:2.c           ****           key_prt = 0xEF;
 181               	r31,hi8(51)
 182               		ld r24,Z
 183 006c E5E3      		andi r24,lo8(15)
 184 006e F0E0      		std Y+2,r24
 186 0072 8083      	.LM15:
  62:2.c           ****           colloc = (PINC & 0x0F);
 187               	24,Y+2
 188               		cpi r24,lo8(15)
 189 0074 E3E3      		breq .L4
 191 0078 8081      	.LM16:
 192 007a 8F70      		std Y+1,__zero_reg__
 193 007c 8A83      		rjmp .L5
  63:2.c           **** 
  64:2.c           **** 			 if(colloc != 0x0F)
 194               	stabn	68,0,69,.LM17-.LFBB1
 195               	.LM17:
 196 007e 8A81      		ldi r30,lo8(53)
 197 0080 8F30      		ldi r31,hi8(53)
 198 0082 01F0      		ldi r24,lo8(-33)
  65:2.c           **** 			 {
  66:2.c           **** 			 	rowloc = 0;
 199               	,r24
 201 0084 1982      	.LM18:
 202 0086 00C0      		ldi r30,lo8(51)
 203               		ldi r31,hi8(51)
  67:2.c           **** 			 	break;
  68:2.c           ****    		 }
  69:2.c           ****    		key_prt  = 0xDF;
 204               	24,Z
 205               		andi r24,lo8(15)
 206 0088 E5E3      		std Y+2,r24
 208 008c 8FED      	.LM19:
 209 008e 8083      		ldd r24,Y+2
  70:2.c           ****    		colloc = (key_pin  &( 0x0F));
 210               	24,lo8(15)
 211               		breq .L6
 213 0092 F0E0      	.LM20:
 214 0094 8081      		ldi r24,lo8(1)
 215 0096 8F70      		std Y+1,r24
 216 0098 8A83      		rjmp .L5
  71:2.c           ****    		
  72:2.c           ****    		if(colloc != 0x0F)
 217               	stabn	68,0,77,.LM21-.LFBB1
 218               	.LM21:
 219 009a 8A81      		ldi r30,lo8(53)
 220 009c 8F30      		ldi r31,hi8(53)
 221 009e 01F0      		ldi r24,lo8(-65)
  73:2.c           ****    		 {
  74:2.c           **** 			 	rowloc = 1;
 222               	,r24
 224 00a0 81E0      	.LM22:
 225 00a2 8983      		ldi r30,lo8(51)
 226 00a4 00C0      		ldi r31,hi8(51)
 227               		ld r24,Z
  75:2.c           **** 			 	break;
  76:2.c           ****    		 }
  77:2.c           ****    		 key_prt  = 0xBF;
 228               	r24,lo8(15)
 229               		std Y+2,r24
 231 00a8 F0E0      	.LM23:
 232 00aa 8FEB      		ldd r24,Y+2
 233 00ac 8083      		cpi r24,lo8(15)
  78:2.c           ****    		 colloc = (key_pin & 0x0F);
 234               	.L7
 236 00ae E3E3      	.LM24:
 237 00b0 F0E0      		ldi r24,lo8(2)
 238 00b2 8081      		std Y+1,r24
 239 00b4 8F70      		rjmp .L5
 240 00b6 8A83      	.L7:
  79:2.c           ****    		if(colloc != 0x0F)
 241               		68,0,84,.LM25-.LFBB1
 242               	.LM25:
 243 00b8 8A81      		ldi r30,lo8(53)
 244 00ba 8F30      		ldi r31,hi8(53)
 245 00bc 01F0      		ldi r24,lo8(127)
  80:2.c           ****    		 {
  81:2.c           **** 			 	rowloc = 2;
 246               	,r24
 248 00be 82E0      	.LM26:
 249 00c0 8983      		ldi r30,lo8(51)
 250 00c2 00C0      		ldi r31,hi8(51)
 251               		ld r24,Z
  82:2.c           **** 			 	break;
  83:2.c           ****    		 }
  84:2.c           ****    		 key_prt  = 0x7F;
 252               	r24,lo8(15)
 253               		std Y+2,r24
 255 00c6 F0E0      	.LM27:
 256 00c8 8FE7      		ldi r24,lo8(3)
 257 00ca 8083      		std Y+1,r24
  85:2.c           ****    		 colloc = (key_pin & 0x0F);
 259               	.LM28:
 260 00cc E3E3      		ldd r24,Y+2
 261 00ce F0E0      		cpi r24,lo8(14)
 262 00d0 8081      		brne .L8
 264 00d4 8A83      	.LM29:
  86:2.c           ****    	    rowloc = 3;
 265               	6,lo8(50)
 266               		ldi r27,hi8(50)
 267 00d6 83E0      		ldd r24,Y+1
 268 00d8 8983      		mov r24,r24
 269               		ldi r25,lo8(0)
  87:2.c           **** 			 break;
  88:2.c           **** 		  }
  89:2.c           **** 		
  90:2.c           **** 		if(colloc == 0x0E)
 270               	r24
 271               		rol r25
 272 00da 8A81      		lsl r24
 273 00dc 8E30      		rol r25
 274 00de 01F4      		movw r30,r24
  91:2.c           **** 		  PORTD = (keypad[rowloc][0]);
 275               	 r30,lo8(-(keypad))
 276               		sbci r31,hi8(-(keypad))
 277 00e0 A2E3      		ld r24,Z
 278 00e2 B0E0      		st X,r24
 279 00e4 8981      		rjmp .L2
 280 00e6 882F      	.L8:
 282 00ea 880F      	.LM30:
 283 00ec 991F      		ldd r24,Y+2
 284 00ee 880F      		cpi r24,lo8(13)
 285 00f0 991F      		brne .L10
 287 00f4 E050      	.LM31:
 288 00f6 F040      		ldi r26,lo8(50)
 289 00f8 8081      		ldi r27,hi8(50)
 290 00fa 8C93      		ldd r24,Y+1
 291 00fc 00C0      		mov r24,r24
 292               		ldi r25,lo8(0)
  92:2.c           **** 		
  93:2.c           **** 	  	else if(colloc == 0x0D)
 293               		lsl r24
 294               		rol r25
 295 00fe 8A81      		movw r30,r24
 296 0100 8D30      		subi r30,lo8(-(keypad+1))
 297 0102 01F4      		sbci r31,hi8(-(keypad+1))
  94:2.c           **** 		  PORTD = (keypad[rowloc][1]);
 298               	24,Z
 299               		st X,r24
 300 0104 A2E3      		rjmp .L2
 301 0106 B0E0      	.L10:
 303 010a 882F      	.LM32:
 304 010c 90E0      		ldd r24,Y+2
 305 010e 880F      		cpi r24,lo8(11)
 306 0110 991F      		brne .L11
 308 0114 991F      	.LM33:
 309 0116 FC01      		ldi r26,lo8(50)
 310 0118 E050      		ldi r27,hi8(50)
 311 011a F040      		ldd r24,Y+1
 312 011c 8081      		mov r24,r24
 313 011e 8C93      		ldi r25,lo8(0)
 314 0120 00C0      		lsl r24
 315               		rol r25
  95:2.c           **** 		
  96:2.c           **** 		else if (colloc == 0x0B)
 316               	24
 317               		rol r25
 318 0122 8A81      		movw r30,r24
 319 0124 8B30      		subi r30,lo8(-(keypad))
 320 0126 01F4      		sbci r31,hi8(-(keypad))
  97:2.c           **** 		  PORTD = (keypad[rowloc][2])  ;
 321               	24,Z
 322               		st X,r24
 323 0128 A2E3      		rjmp .L2
 324 012a B0E0      	.L11:
 326 012e 882F      	.LM34:
 327 0130 90E0      		ldi r26,lo8(50)
 328 0132 880F      		ldi r27,hi8(50)
 329 0134 991F      		ldd r24,Y+1
 330 0136 0196      		mov r24,r24
 331 0138 880F      		ldi r25,lo8(0)
 332 013a 991F      		lsl r24
 333 013c FC01      		rol r25
 334 013e E050      		lsl r24
 335 0140 F040      		rol r25
 336 0142 8081      		movw r30,r24
 337 0144 8C93      		subi r30,lo8(-(keypad+3))
 338 0146 00C0      		sbci r31,hi8(-(keypad+3))
 339               		ld r24,Z
  98:2.c           **** 		else
  99:2.c           **** 		  PORTD = (keypad[rowloc][3]);
 340               	bn	68,0,99,.LM34-.LFBB1
 341               	.LM34:
 342 0148 A2E3      		ldi r26,lo8(50)
 343 014a B0E0      		ldi r27,hi8(50)
 344 014c 8981      		ldd r24,Y+1
 345 014e 882F      		mov r24,r24
 346 0150 90E0      		ldi r25,lo8(0)
 347 0152 880F      		lsl r24
 348 0154 991F      		rol r25
 349 0156 880F      		lsl r24
 350 0158 991F      		rol r25
 351 015a FC01      		movw r30,r24
 352 015c E050      		subi r30,lo8(-(keypad+3))
 353 015e F040      		sbci r31,hi8(-(keypad+3))
 354 0160 8081      		ld r24,Z
 355 0162 8C93      		st X,r24
 356 0164 00C0      		rjmp .L2
 362               	.Lscope1:
 365               	.global	delay_ms
 367               	delay_ms:
 100:2.c           ****     }
 101:2.c           **** 
 102:2.c           ****   return 0;
 103:2.c           **** 
 104:2.c           **** }
 105:2.c           **** 
 106:2.c           **** void delay_ms(unsigned int d)
 107:2.c           **** {
 368               	28,0,0,1
 371 0166 DF93      	.Lscope1:
 374 016c DEB7      	.global	delay_ms
 376 0170 0FB6      	delay_ms:
 378 0174 DEBF      	.LM35:
 379 0176 0FBE      	.LFBB2:
 380 0178 CDBF      		push r29
 381               		push r28
 382               		in r28,__SP_L__
 383 017a 988B      		in r29,__SP_H__
 384 017c 8F87      		sbiw r28,16
 108:2.c           **** 		_delay_ms(d);
 385               	_ms
 387 017e 8F85      	.global	delay_ms
 389 0182 CC01      	delay_ms:
 391 0186 B0E0      	.LM35:
 392 0188 BC01      	.LFBB2:
 393 018a CD01      		push r29
 394 018c 00D0      		push r28
 395 018e DC01      		in r28,__SP_L__
 396 0190 CB01      		in r29,__SP_H__
 397 0192 8B87      		sbiw r28,16
 398 0194 9C87      		in __tmp_reg__,__SREG__
 399 0196 AD87      		cli
 400 0198 BE87      		out __SP_H__,r29
 401               		out __SREG__,__tmp_reg__
 402               		out __SP_L__,r28
 403               	/* prologue: function */
 404               	/* frame size = 16 */
   1:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****    All rights reserved.
   5:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** 
   6:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** 
   9:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** 
  12:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****      distribution.
  16:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** 
  17:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** 
  21:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** 
  33:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** /* $Id: delay.h,v 1.5 2007/10/28 23:25:56 joerg_wunsch Exp $ */
  34:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** 
  35:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** 
  38:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** #include <inttypes.h>
  39:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** #include <util/delay_basic.h>
  40:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** 
  41:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** /** \file */
  42:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  43:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****     \code
  44:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  45:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  46:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****     #include <util/delay.h>
  47:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****     \endcode
  48:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** 
  49:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  50:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  51:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  52:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****     used.
  53:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** 
  54:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  55:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  56:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  57:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  58:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  59:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  60:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  61:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  62:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** 
  63:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  64:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  65:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  66:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  67:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  68:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  69:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  70:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****     routines linked into the application.
  71:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** 
  72:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  73:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  74:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  75:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** 
  76:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** */
  77:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** 
  78:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  79:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** static inline void _delay_us(double __us) __attribute__((always_inline));
  80:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** static inline void _delay_ms(double __ms) __attribute__((always_inline));
  81:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** #endif
  82:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** 
  83:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** #ifndef F_CPU
  84:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  85:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  86:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** # define F_CPU 1000000UL
  87:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** #endif
  88:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** 
  89:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** #ifndef __OPTIMIZE__
  90:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
  91:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** #endif
  92:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** 
  93:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** /**
  94:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****    \ingroup util_delay
  95:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** 
  96:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
  97:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** 
  98:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
  99:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 100:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** 
 101:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 102:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** 
 103:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****    If the user requests a delay greater than the maximal possible one,
 104:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 105:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****    will not be informed about this case.
 106:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****  */
 107:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** void
 108:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** _delay_us(double __us)
 109:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** {
 110:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** 	uint8_t __ticks;
 111:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** 	double __tmp = ((F_CPU) / 3e6) * __us;
 112:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** 	if (__tmp < 1.0)
 113:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** 		__ticks = 1;
 114:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** 	else if (__tmp > 255)
 115:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** 	{
 116:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** 		_delay_ms(__us / 1000.0);
 117:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** 		return;
 118:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** 	}
 119:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** 	else
 120:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** 		__ticks = (uint8_t)__tmp;
 121:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** 	_delay_loop_1(__ticks);
 122:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** }
 123:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** 
 124:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** 
 125:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** /**
 126:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****    \ingroup util_delay
 127:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** 
 128:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 129:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** 
 130:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 131:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 132:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** 
 133:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 134:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** 
 135:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 136:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 137:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 138:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 139:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 140:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****  */
 141:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** void
 142:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** _delay_ms(double __ms)
 143:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** {
 144:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** 	uint16_t __ticks;
 145:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** 	double __tmp = ((F_CPU) / 4e3) * __ms;
 405               	sh r28
 406               		in r28,__SP_L__
 407 019a 20E0      		in r29,__SP_H__
 408 019c 30E0      		sbiw r28,16
 409 019e 4AE7      		in __tmp_reg__,__SREG__
 410 01a0 53E4      		cli
 411 01a2 6B85      		out __SP_H__,r29
 412 01a4 7C85      		out __SREG__,__tmp_reg__
 413 01a6 8D85      		out __SP_L__,r28
 414 01a8 9E85      	/* prologue: function */
 415 01aa 00D0      	/* frame size = 16 */
 416 01ac DC01      		std Y+16,r25
 417 01ae CB01      		std Y+15,r24
 419 01b2 9887      	.LM36:
 420 01b4 A987      		ldd r24,Y+15
 421 01b6 BA87      		ldd r25,Y+16
 146:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** 	if (__tmp < 1.0)
 422               	29
 423               		out __SREG__,__tmp_reg__
 424 01b8 20E0      		out __SP_L__,r28
 425 01ba 30E0      	/* prologue: function */
 426 01bc 40E8      	/* frame size = 16 */
 427 01be 5FE3      		std Y+16,r25
 428 01c0 6F81      		std Y+15,r24
 430 01c4 8985      	.LM36:
 431 01c6 9A85      		ldd r24,Y+15
 432 01c8 00D0      		ldd r25,Y+16
 433 01ca 8823      		movw r24,r24
 434 01cc 04F4      		ldi r26,lo8(0)
 435               		ldi r27,hi8(0)
 147:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** 		__ticks = 1;
 436               	 prologue: function */
 437               	/* frame size = 16 */
 438 01ce 81E0      		std Y+16,r25
 439 01d0 90E0      		std Y+15,r24
 441 01d4 8D83      	.LM36:
 442 01d6 00C0      		ldd r24,Y+15
 443               		ldd r25,Y+16
 148:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** 	else if (__tmp > 65535)
 444               	29
 445               		out __SREG__,__tmp_reg__
 446 01d8 20E0      		out __SP_L__,r28
 447 01da 3FEF      	/* prologue: function */
 448 01dc 4FE7      	/* frame size = 16 */
 449 01de 57E4      		std Y+16,r25
 450 01e0 6F81      		std Y+15,r24
 452 01e4 8985      	.LM36:
 453 01e6 9A85      		ldd r24,Y+15
 454 01e8 00D0      		ldd r25,Y+16
 455 01ea 1816      		movw r24,r24
 456 01ec 04F4      		ldi r26,lo8(0)
 457               		ldi r27,hi8(0)
 149:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** 	{
 150:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** 		//	__ticks = requested delay in 1/10 ms
 151:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 458               	 prologue: function */
 459               	/* frame size = 16 */
 460 01ee 20E0      		std Y+16,r25
 461 01f0 30E0      		std Y+15,r24
 463 01f4 51E4      	.LM36:
 464 01f6 6B85      		ldd r24,Y+15
 465 01f8 7C85      		ldd r25,Y+16
 466 01fa 8D85      		movw r24,r24
 467 01fc 9E85      		ldi r26,lo8(0)
 468 01fe 00D0      		ldi r27,hi8(0)
 469 0200 DC01      		movw r22,r24
 470 0202 CB01      		movw r24,r26
 471 0204 BC01      		rcall __floatunsisf
 472 0206 CD01      		movw r26,r24
 473 0208 00D0      		movw r24,r22
 474 020a DC01      		std Y+11,r24
 475 020c CB01      		std Y+12,r25
 476 020e 9E83      		std Y+13,r26
 477 0210 8D83      		std Y+14,r27
 478 0212 00C0      	.LBB8:
 479               	.LBB9:
 481 0216 90E0      	.Ltext1:
 483 021a 8B83      	.LM37:
 484               		ldi r18,lo8(0x437a0000)
 485               		ldi r19,hi8(0x437a0000)
 486               		ldi r20,hlo8(0x437a0000)
 487               		ldi r21,hhi8(0x437a0000)
   1:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****    Copyright (c) 2007 Joerg Wunsch
   3:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****    All rights reserved.
   4:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 
   5:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****    Redistribution and use in source and binary forms, with or without
   6:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****    modification, are permitted provided that the following conditions are met:
   7:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 
   8:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****    * Redistributions of source code must retain the above copyright
   9:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****      notice, this list of conditions and the following disclaimer.
  10:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 
  11:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****    * Redistributions in binary form must reproduce the above copyright
  12:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****      notice, this list of conditions and the following disclaimer in
  13:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****      the documentation and/or other materials provided with the
  14:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****      distribution.
  15:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 
  16:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****    * Neither the name of the copyright holders nor the names of
  17:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****      contributors may be used to endorse or promote products derived
  18:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****      from this software without specific prior written permission.
  19:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 
  20:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  21:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  22:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  23:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  24:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  25:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  26:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  27:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  28:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  29:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  30:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****   POSSIBILITY OF SUCH DAMAGE. */
  31:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 
  32:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** /* $Id: delay_basic.h,v 1.1 2007/05/13 21:23:20 joerg_wunsch Exp $ */
  33:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 
  34:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** #ifndef _UTIL_DELAY_BASIC_H_
  35:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** #define _UTIL_DELAY_BASIC_H_ 1
  36:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 
  37:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** #include <inttypes.h>
  38:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 
  39:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** /** \file */
  40:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** /** \defgroup util_delay_basic <util/delay_basic.h>: Basic busy-wait delay loops
  41:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     \code
  42:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     #include <util/delay_basic.h>
  43:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     \endcode
  44:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 
  45:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     The functions in this header file implement simple delay loops
  46:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     that perform a busy-waiting.  They are typically used to
  47:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     facilitate short delays in the program execution.  They are
  48:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     implemented as count-down loops with a well-known CPU cycle
  49:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     count per loop iteration.  As such, no other processing can
  50:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     occur simultaneously.  It should be kept in mind that the
  51:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     functions described here do not disable interrupts.
  52:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 
  53:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     In general, for long delays, the use of hardware timers is
  54:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     much preferrable, as they free the CPU, and allow for
  55:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     concurrent processing of other events while the timer is
  56:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     running.  However, in particular for very short delays, the
  57:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     overhead of setting up a hardware timer is too much compared
  58:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     to the overall delay time.
  59:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 
  60:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     Two inline functions are provided for the actual delay algorithms.
  61:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 
  62:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** */
  63:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 
  64:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** #if !defined(__DOXYGEN__)
  65:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** static inline void _delay_loop_1(uint8_t __count) __attribute__((always_inline));
  66:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** static inline void _delay_loop_2(uint16_t __count) __attribute__((always_inline));
  67:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** #endif
  68:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 
  69:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** /** \ingroup util_delay_basic
  70:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 
  71:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     Delay loop using an 8-bit counter \c __count, so up to 256
  72:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     iterations are possible.  (The value 256 would have to be passed
  73:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     as 0.)  The loop executes three CPU cycles per iteration, not
  74:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     including the overhead the compiler needs to setup the counter
  75:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     register.
  76:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 
  77:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     Thus, at a CPU speed of 1 MHz, delays of up to 768 microseconds
  78:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     can be achieved.
  79:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** */
  80:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** void
  81:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** _delay_loop_1(uint8_t __count)
  82:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** {
  83:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 	__asm__ volatile (
  84:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 		"1: dec %0" "\n\t"
  85:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 		"brne 1b"
  86:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 		: "=r" (__count)
  87:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 		: "0" (__count)
  88:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 	);
  89:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** }
  90:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 
  91:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** /** \ingroup util_delay_basic
  92:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 
  93:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     Delay loop using a 16-bit counter \c __count, so up to 65536
  94:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     iterations are possible.  (The value 65536 would have to be
  95:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     passed as 0.)  The loop executes four CPU cycles per iteration,
  96:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     not including the overhead the compiler requires to setup the
  97:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     counter register pair.
  98:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 
  99:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     Thus, at a CPU speed of 1 MHz, delays of up to about 262.1
 100:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     milliseconds can be achieved.
 101:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****  */
 102:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** void
 103:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** _delay_loop_2(uint16_t __count)
 104:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** {
 105:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 	__asm__ volatile (
 488               	,132,0,0,.Ltext1
 489               	.Ltext1:
 491 021e 9C81      	.LM37:
 492               		ldi r18,lo8(0x437a0000)
 493               		ldi r19,hi8(0x437a0000)
 494 0220 0197      		ldi r20,hlo8(0x437a0000)
 495 0222 01F4      		ldi r21,hhi8(0x437a0000)
 496               		ldd r22,Y+11
 497               		ldd r23,Y+12
 498 0224 9C83      		ldd r24,Y+13
 499 0226 8B83      		ldd r25,Y+14
 500               		rcall __mulsf3
 501               		movw r26,r24
 502               		movw r24,r22
 503               		std Y+7,r24
 152:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** 		while(__ticks)
 153:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** 		{
 154:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** 			// wait 1/10 ms
 155:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 156:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** 			__ticks --;
 504               	,hlo8(0x437a0000)
 505               		ldi r21,hhi8(0x437a0000)
 506 0228 8D81      		ldd r22,Y+11
 507 022a 9E81      		ldd r23,Y+12
 508 022c 0197      		ldd r24,Y+13
 509 022e 9E83      		ldd r25,Y+14
 510 0230 8D83      		rcall __mulsf3
 511               		movw r26,r24
 512               		movw r24,r22
 513               		std Y+7,r24
 514 0232 8D81      		std Y+8,r25
 515 0234 9E81      		std Y+9,r26
 516 0236 0097      		std Y+10,r27
 518 023a 00C0      	.LM38:
 519               		ldi r18,lo8(0x3f800000)
 157:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** 		}
 158:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** 		return;
 159:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** 	}
 160:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** 	else
 161:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** 		__ticks = (uint16_t)__tmp;
 520               	_mulsf3
 521               		movw r26,r24
 522 023c 6F81      		movw r24,r22
 523 023e 7885      		std Y+7,r24
 524 0240 8985      		std Y+8,r25
 525 0242 9A85      		std Y+9,r26
 526 0244 00D0      		std Y+10,r27
 528 0248 CB01      	.LM38:
 529 024a 9E83      		ldi r18,lo8(0x3f800000)
 530 024c 8D83      		ldi r19,hi8(0x3f800000)
 531               		ldi r20,hlo8(0x3f800000)
 532 024e 8D81      		ldi r21,hhi8(0x3f800000)
 533 0250 9E81      		ldd r22,Y+7
 534 0252 9A83      		ldd r23,Y+8
 535 0254 8983      		ldd r24,Y+9
 536               		ldd r25,Y+10
 537               		rcall __ltsf2
 538               		tst r24
 539               		brge .L25
 540               	.L23:
 542 0256 8981      	.LM39:
 543 0258 9A81      		ldi r24,lo8(1)
 544               		ldi r25,hi8(1)
 545               		std Y+6,r25
 546 025a 0197      		std Y+5,r24
 547 025c 01F4      		rjmp .L16
 548               	.L25:
 550 025e 9A83      	.LM40:
 551 0260 8983      		ldi r18,lo8(0x477fff00)
 552               		ldi r19,hi8(0x477fff00)
 553               		ldi r20,hlo8(0x477fff00)
 554               		ldi r21,hhi8(0x477fff00)
 555               		ldd r22,Y+7
 556               		ldd r23,Y+8
 557               		ldd r24,Y+9
 558               		ldd r25,Y+10
 559               		rcall __gtsf2
 109:2.c           **** }
 560               	
 561               		ldi r20,hlo8(0x477fff00)
 562 0262 6096      		ldi r21,hhi8(0x477fff00)
 563 0264 0FB6      		ldd r22,Y+7
 564 0266 F894      		ldd r23,Y+8
 565 0268 DEBF      		ldd r24,Y+9
 566 026a 0FBE      		ldd r25,Y+10
 567 026c CDBF      		rcall __gtsf2
 568 026e CF91      		cp __zero_reg__,r24
 569 0270 DF91      		brge .L26
 570 0272 0895      	.L24:
 572               	.LM41:
 573               		ldi r18,lo8(0x41200000)
 574               		ldi r19,hi8(0x41200000)
 575               		ldi r20,hlo8(0x41200000)
DEFINED SYMBOLS
                            *ABS*:00000000 2.c
C:\users\batch2\Temp/ccWMcCvb.s:2      *ABS*:0000003f __SREG__
C:\users\batch2\Temp/ccWMcCvb.s:3      *ABS*:0000003e __SP_H__
C:\users\batch2\Temp/ccWMcCvb.s:4      *ABS*:0000003d __SP_L__
C:\users\batch2\Temp/ccWMcCvb.s:5      *ABS*:00000034 __CCP__
C:\users\batch2\Temp/ccWMcCvb.s:6      *ABS*:00000000 __tmp_reg__
C:\users\batch2\Temp/ccWMcCvb.s:7      *ABS*:00000001 __zero_reg__
C:\users\batch2\Temp/ccWMcCvb.s:74     .data:00000000 keypad
C:\users\batch2\Temp/ccWMcCvb.s:95     .text:00000000 main
C:\users\batch2\Temp/ccWMcCvb.s:367    .text:00000166 delay_ms

UNDEFINED SYMBOLS
__do_copy_data
__do_clear_bss
__floatunsisf
__mulsf3
__ltsf2
__gtsf2
__fixunssfsi
